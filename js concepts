* Hoisting ==============
  - Hoisting is a JavaScript mechanism where variable and function declarations are allocated memory before code execution.
  - In hoisting, var stores 'undefined', function stores full function body, and let/const are given memory but can't be 
    accessed because they are in temporal dead zone (which is the time between a variable is hoisted till it's given a value).

* Closure =============
  - Closure is a function bound with its lexical scope.
  - When a function returns a function, it's also returning the lexical scope of it, which is called closure.
  - Closure is formed when a function retains access to its parent scope even after the parent function has returned.
  - Example: function outer() {
                let count = 0;
              
                function inner() {
                  count++;
                  console.log(count);
                }
              
                return inner;
              }
              
              const counter = outer();
              
              counter(); // 1
              counter(); // 2
              counter(); // 3

    - Closure is created at function definition, not function execution.
    - Advantages: Data encapsulation, Data privacy.
    - Disadvantages: Memory leaks, takes more space because the value is not garbage-collected.




* Deep copy v/s Shallow copy ==============
  - A shallow copy copies only one level of an object.
    ğŸ‘‰ If the object has nested objects/arrays, the inner references are shared (not copied).
         Example:
            const original = { 
              name: "Nagendra", 
              address: { city: "Noida" } 
            };
          
          // Shallow copy
          const shallow = { ...original };
          
          shallow.name = "Sam";        // âœ… Only affects shallow copy
          shallow.address.city = "Goa"; // âŒ Changes original too!
          
          console.log(original.name);        // "Alex"
          console.log(original.address.city); // "Goa" (changed!)

    - A deep copy copies the object and all nested objects, so changes in one do not affect the other.
      const deep = structuredClone(original); // using structuredClone, available in modern JS
      Or, const deep = JSON.parse(JSON.stringify(original) // (but fails for dates, functions, undefined, etc.)
      Or, Libraries like Lodash (_.cloneDeep(original))


* DEBOUNCING =================
  - If an event keeps firing rapidly (like typing or scrolling), debouncing waits until the activity stops for X milliseconds before running the function.
  - Example:
        useEffect(() => {
            let timer;
            if (val) {
              timer = setTimeout(() => {   // here multiple setTimeouts will be stacking up if user types continuously inside our input field
                console.log("Api called...");  
              }, 1000);
            }
            return () => {
              clearTimeout(timer);  // this cleanup function actually runs at first, to clear all previously stacked setTimeouts, if val changes
            };
          }, [val]);

        <input type="text" value={val} onChange={(e) => setVal(e.target.value)} />  // Usage in searchbox


* THROTTLING =================
  - Throttling is a technique where you make sure a function executes at most once in a given interval, no matter how many times the event is triggered.
  - Example, Button clicks: Prevents users from spamming a button (like "Submit Order") multiple times in quick succession.

            function throttle(func, delay) {
              let timer;
              return () => {
                if (!timer) {
                  func();
                  timer = setTimeout(() => {
                    timer = null;
                  }, delay);
                }
              };
            }
        
          const handleClick = throttle(() => {
            console.log("clicked...");
          }, 1000);
        
          return (
            <div className="App">
              <button onClick={handleClick}>click</button>  // Even if we click repeatedly, console will be logged only once in every second of clicks.
            </div>
          );


* call, apply, and bind =====================
  - call, apply, and bind are methods that allow explicit binding of this for function execution.
  - Example: 

        function greet(city, country) {
          console.log(this.name, city, country);
        }
        
        const user = { name: "Amit" };

        greet.call(user, "Delhi", "India");         // prints Amit, Delhi, India
        
        greet.apply(user, ["Delhi", "India"]);      // prints Amit, Delhi, India
  
        const boundFn = greet.bind(user, "Delhi");
        boundFn("India");                          // prints Amit, Delhi, India



* Event Loop ==============
  - The event loop continuously checks whether the call stack is empty and pushes queued callbacks for execution.
  - Suppose we have a setTimeout containing a callback func. When the timer gets expired, the callback queue stores this 
    callback func. Then it's the 'Event loop' which puts this callback func inside the call stack(when it's empty).

      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚  Call Stack  â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†‘
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ Microtask Queue  â”‚ â† higher priority (promises)
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â†‘
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚  MacroTask Queue â”‚ â† lower priority (setTimeout, setInterval, events like click or scroll)
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


* async/await ===========
  - async / await is syntactic sugar built on top of Promises. 
  - async/await make promise based functions to behave as synchronous by pausing the execution.
  - async function always returns a Promise
  - await pauses execution of the function â€” not the call stack.
  - Example: 

        console.log("A");   
      
        async function test() {
          console.log("B");
        
          await Promise.resolve();
        
          console.log("C");
        }
        
        test();
      
        console.log("D");

    Execution timeline:
      1ï¸âƒ£ A â†’ sync
      2ï¸âƒ£ test() called
      3ï¸âƒ£ B printed
      4ï¸âƒ£ await encountered â†’ pause function
      5ï¸âƒ£ Remaining code scheduled as microtask
      6ï¸âƒ£ D printed
      7ï¸âƒ£ Microtask runs â†’ C




