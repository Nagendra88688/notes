* Deep copy v/s Shallow copy ==============
  - A shallow copy copies only one level of an object.
    👉 If the object has nested objects/arrays, the inner references are shared (not copied).
         Example:
            const original = { 
              name: "Nagendra", 
              address: { city: "Noida" } 
            };
          
          // Shallow copy
          const shallow = { ...original };
          
          shallow.name = "Sam";        // ✅ Only affects shallow copy
          shallow.address.city = "Goa"; // ❌ Changes original too!
          
          console.log(original.name);        // "Alex"
          console.log(original.address.city); // "Goa" (changed!)

    - A deep copy copies the object and all nested objects, so changes in one do not affect the other.
      const deep = structuredClone(original); // using structuredClone, available in modern JS
      Or, const deep = JSON.parse(JSON.stringify(original) // (but fails for dates, functions, undefined, etc.)
      Or, Libraries like Lodash (_.cloneDeep(original))


* DEBOUNCING =================
  - If an event keeps firing rapidly (like typing or scrolling), debouncing waits until the activity stops for X milliseconds before running the function.
  - Example:
        useEffect(() => {
            let timer;
            if (val) {
              timer = setTimeout(() => {   // here multiple setTimeouts will be stacking up if user types continuously inside our input field
                console.log("Api called...");  
              }, 1000);
            }
            return () => {
              clearTimeout(timer);  // this cleanup function actually runs at first, to clear all previously stacked setTimeouts, if val changes
            };
          }, [val]);

        <input type="text" value={val} onChange={(e) => setVal(e.target.value)} />  // Usage in searchbox


* THROTTLING =================
  - Throttling is a technique where you make sure a function executes at most once in a given interval, no matter how many times the event is triggered.
  - Example, Button clicks: Prevents users from spamming a button (like "Submit Order") multiple times in quick succession.

            function throttle(func, delay) {
              let timer;
              return () => {
                if (!timer) {
                  func();
                  timer = setTimeout(() => {
                    timer = null;
                  }, delay);
                }
              };
            }
        
          const handleClick = throttle(() => {
            console.log("clicked...");
          }, 1000);
        
          return (
            <div className="App">
              <button onClick={handleClick}>click</button>  // Even if we click repeatedly, console will be logged only once in every second of clicks.
            </div>
          );
