* A Promise is an object that represents the eventual completion (or failure) of an asynchronous operation.

* It has three states:

 -pending → initial state

 -fulfilled → operation succeeded (resolved)

 -rejected → operation failed (rejected)

* Promise.all([p1, p2]) → Resolves when all promises resolve; rejects if any one fails.

* Promise.allSettled([p1, p2]) → Resolves after all promises settle (success/fail) with their status.

* Promise.race([p1, p2]) → Resolves/rejects as soon as the first promise settles.

* Promise.any([p1, p2]) → Resolves when first successful promise resolves; rejects only if all fail.

* Why Promises? => Promises help us to deal with asynchronous code in a far simpler way compared to callbacks. 
                  (Callback hell can be avoided by Promises)

                   Using callbacks->
                        getUser(id, function (user) {
                          getOrders(user.id, function (orders) {
                            getPayment(orders[0].id, function (payment) {        // Callback hell
                              console.log(payment);
                            }, handleError);
                          }, handleError);
                        }, handleError);

                  Same logic with Promises->
                       getUser(id)
                        .then(user => getOrders(user.id))
                        .then(orders => getPayment(orders[0].id))
                        .then(payment => {
                          console.log(payment);
                        })
                        .catch(error => {
                          console.error(error);
                        });



* CREATING A PROMISE ==========
        const myPromise = new Promise((resolve, reject) => {
        // Do some async work
        let success = true;
      
        if (success) {
          resolve("✅ Task completed!");
        } else {
          reject("❌ Something went wrong");
        }
      });

  * Consuming the Promise ----
      myPromise
        .then(result => {
          console.log("Resolved:", result);
        })
        .catch(error => {
          console.log("Rejected:", error);
        })
        .finally(() => {
          console.log("Promise finished");
        });


 * OUTPUT BASED QUESTIONS =================

      1.   console.log("Start");                                ==> OUTPUT : "Start", "Inside Promise", "End", "Resolved"
          
          const p = new Promise((resolve, reject) => {
            console.log("Inside Promise");
            resolve("Resolved!");
          });
          
          p.then(res => console.log(res));
          
          console.log("End");


      2. Promise.resolve().then(() => {                  ===> OUTPUT: 1, 3, 2 (Microtasks are executed in order, but new promises inside .then are queued later.)
          console.log("1");
          return Promise.resolve("2");
        }).then(res => {
          console.log(res);
        });
        
        Promise.resolve().then(() => console.log("3"));

      3. async function test() {                     ===========> OUTPUT: A, C, B
        console.log("A");
        await Promise.resolve();
        console.log("B");
      }
      test();
      console.log("C");

      4. console.log("Start");                        ================> OUTPUT: Start, End, Promise 1, Promise 2, setTimeout  
      
      setTimeout(() => console.log("setTimeout"), 0);
      
      Promise.resolve().then(() => console.log("Promise 1"))
        .then(() => console.log("Promise 2"));
      
      console.log("End");

   5. const first = new Promise((res) => setTimeout(()=>res("First"), 100));    
   const second = new Promise((res) => res("Second"));
   
   Promise.race([first, second]).then(val => console.log(val));       =========>OUTPUT: Second

  6. async function foo() {
    try {
      return await Promise.reject("Oops!");
    } catch (e) {
      return "Handled: " + e;
    }
  }
  
  foo().then(console.log);      ==========> Output: Handled: Oops







