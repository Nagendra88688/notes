* Good Practices for React Optimization =======
      ‚úÖ Use React.memo for functional components to prevent unnecessary re-renders.
      ‚úÖ Use useCallback & useMemo for expensive functions and computed values.
      ‚úÖ Provide a stable key prop when rendering lists (avoid using array index if possible).
      ‚úÖ Split large components into smaller reusable components.
      ‚úÖ Use React.lazy + Suspense for route-based or component-level lazy loading.
      ‚úÖ Split vendor libraries (e.g., charts, editors) into separate bundles using Webpack or Vite.
      ‚úÖ Load non-critical components only when needed (modals, dropdowns).
      ‚úÖ Use uncontrolled components for forms if you don‚Äôt need to track every keystroke.
      ‚úÖ Use windowing/virtualization libraries (React Window, React Virtualized) for large lists.
      ‚úÖ Cache API responses using React Query, SWR, or RTK Query.
      ‚úÖ Debounce/throttle expensive API calls (like search).
      ‚úÖ Prefer Redux Toolkit / Zustand / Jotai for scalable global state.

* New features in latest version of React (19) ===========
  * Refs as props directly (i.e. no more forwardRef in many common cases) 
  * use() API: Allows reading a Promise or resource directly inside render (instead of via side effects), with built-in support for Suspense, etc. 
               Simplifies async data fetching in some rendering scenarios.


* LAZY LOADING =================
      - Lazy loading is a frontend optimization where resources (like images, components, or routes) are loaded only when 
      they are needed, instead of all initially loading at once. This improves performance and reduces bandwidth usage.

      -     import React, { Suspense, lazy } from "react";

            const Profile = lazy(() => import("./Profile")); // Lazy load component
            
            function App() {
              return (
                <div>
                  <h1>Dashboard</h1>
                  <Suspense fallback={<p>Loading profile...</p>}>
                    <Profile />  {/* Loaded only when needed */}
                  </Suspense>
                </div>
              );
            }

      - Lazy loading does the Code splitting, which is a performance optimization technique where your application‚Äôs JavaScript bundle is split
        into smaller chunks instead of one big file.


* React Virtualized============
       - React Virtualized is a popular library for efficiently rendering large lists, tables, and grids in React.
      
      üëâ Instead of rendering thousands of DOM nodes at once (which slows down the app), React Virtualized only renders the items that are visible
          in the viewport plus a small buffer.
      üëâ As you scroll, it reuses DOM nodes and renders new items dynamically.
      
      This technique is called windowing or virtualization.


* Ref ================
  - A ref is like a pointer for a value, or a DOM element.
  - It gives a way to directly access and interact with something React manages (like an <input> or a value that should persist across renders).
  - Unlike state, changing a ref does not trigger a re-render, and refs persist during re-renders. So refs can be used to store render counts.
  - const myRef = useRef(initialValue);   => useRef(initialValue) returns an object { current: initialValue } 
  - The ".current" property can be mutated freely.
  - Usage(to focus input) :
          const inputRef = useRef(null);  // Declaration

          <>
            <input ref={inputRef} type="text" />                  // now, this inputRef will contain the actual <input> DOM node.
            <button onClick={()=>inputRef.current.focus()}>Focus Input</button>   
          </>

 * React.StrictMode ===============
   - It‚Äôs a wrapper component that helps you find potential problems in your React code.
   - Think of it like a developer tool (it doesn‚Äôt affect production).
   - Warns if you use outdated lifecycle methods
   - In React 18+, it intentionally runs certain functions twice (like useEffect cleanup/setup, component constructors, and render) 
     to help you spot side-effects that shouldn‚Äôt exist.
   - Development-only tool for catching bugs early.

* useEffect v/s useLayoutEffect ===================
    üî∏ useEffect
            * Runs asynchronously after paint (after the browser updates the screen).
            * Non-blocking ‚Üí the UI is updated first, then the effect runs.
            * Best for: side effects that don‚Äôt affect layout/paint.

    üî∏ useLayoutEffect
            * Runs synchronously after DOM updates but before paint.
            * Blocks painting until it finishes ‚Üí can cause flicker if misused.
            * Best for: measuring DOM, synchronously re-rendering, or adjusting layout before the user sees it.
            * example, useLayoutEffect(() => {
                           setWidth(boxRef.current.getBoundingClientRect().width);
                        }, []);
                                                        



* HOW THE INTERNET WORKS ============
        - You type a URL in the browser
        - The browser checks cache (or your OS / ISP cache) to see if it already knows the IP address of the server.
        - If not, it queries a DNS server to translate the domain name (www.google.com) into an IP address (e.g., 142.250.182.4).
        - The browser now knows the IP address and uses the TCP/IP protocol to connect.
        - The browser sends an HTTP request (e.g., GET /) to the server over the TCP connection. (TCP is a Protocol for reliable data transfer)
        - This request travels through multiple routers, ISPs, and undersea cables until it reaches the destination server.
        - The server receives the request. It may query databases, run backend logic, and then prepare a response (HTML, JSON, etc.).
        - The server sends back an HTTP response (e.g., HTML for a webpage) to the browser.
        - The response is rendered on Browser.

* How a Webpage Loads in the Browser =====
                  HTML ‚Üí DOM
                  CSS  ‚Üí CSSOM
                  DOM + CSSOM ‚Üí Render Tree
                  Render Tree ‚Üí Layout
                  Layout ‚Üí Paint
                  Paint ‚Üí Composite

      - When the browser receives HTML, it parses it into a DOM tree. (JS is included in parsing)
      - In parallel, CSS is parsed into a CSSOM tree.
      - The DOM and CSSOM are combined to form the render tree, which contains only visible elements with their computed styles.
      - The browser then performs layout to calculate the exact size and position of each element.
      - After layout, the paint phase draws pixels such as text, colors, borders and images into layers.
      - Finally, these layers are composited by the GPU to produce the final UI on screen.

* CDN : A CDN is a network of globally distributed servers that cache and deliver content to users from the nearest location. 
        This reduces latency, speeds up page loads, decreases server load, and improves reliability. 
        For frontend, CDNs are commonly used to serve static assets like JavaScript, CSS, and images.
        Some common CDN providers are: Akamai, Cloudflare, & Netlify Edge.

* VITE =============================
  - It is a next-generation frontend build tool designed to provide faster development and optimized builds compared to traditional bundlers like Webpack.
  - Traditional bundlers (like Webpack) rebuild and rebundle your entire app when a file changes ‚Üí slow dev server for large projects. Vite solves this by using native ES modules in development.
  - When you start the dev server, Vite doesn‚Äôt bundle everything. It only serves files on demand ‚Äî if you open App.jsx, only that file and its dependencies are compiled.
  - Uses esbuild (written in Go) for lightning-fast compilation.


* LIFECYCLE METHODS IN CLASS COMPONENTS =======
      (Mounting phase)
            - constructor 
            - static getDerivedStateFromProps
            - render
            - componentDidMount

      (Updating phase)
            - static getDerivedStateFromProps
            - shouldComponentUpdate
            - render
            - getSnapshotBeforeUpdate
            - componentDidUpdate

      (Unmounting phase)
            - componentWillUnmount

      (Error handling phase)
            - static getDerivedStateFromError
            - componentDidCatch

* Reconciliation : It is the process by which React compares the previous Virtual DOM tree with the new one to determine 
                   the minimal set of changes needed to update the real DOM, using Diffig Algorithm.



* Context API =============
      - It helps us to avoid Prop drilling.

      1Ô∏è‚É£ createContext
            const ThemeContext = React.createContext("light");

      2Ô∏è‚É£ Provide
            <ThemeContext.Provider value="dark">
              <App />
            </ThemeContext.Provider>

      3Ô∏è‚É£ Consume in child
            const theme = useContext(ThemeContext);

* What is Batching ? 
      - Batching in React is an optimization where multiple state updates are grouped together
        and cause only one re-render instead of many.
      - example, function handleClick() {
                    setA(1);
                    setB(2);             // react collect updates -> merge updates -> render once
                  }

