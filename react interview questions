* Good Practices for React Optimization =======
      âœ… Use React.memo for functional components to prevent unnecessary re-renders.
      âœ… Use useCallback & useMemo for expensive functions and computed values.
      âœ… Provide a stable key prop when rendering lists (avoid using array index if possible).
      âœ… Split large components into smaller reusable components.
      âœ… Use React.lazy + Suspense for route-based or component-level lazy loading.
      âœ… Split vendor libraries (e.g., charts, editors) into separate bundles using Webpack or Vite.
      âœ… Load non-critical components only when needed (modals, dropdowns).
      âœ… Use uncontrolled components for forms if you donâ€™t need to track every keystroke.
      âœ… Use windowing/virtualization libraries (React Window, React Virtualized) for large lists.
      âœ… Cache API responses using React Query, SWR, or RTK Query.
      âœ… Debounce/throttle expensive API calls (like search).
      âœ… Prefer Redux Toolkit / Zustand / Jotai for scalable global state.

* New features in latest version of React (19) ===========
  * Refs as props directly (i.e. no more forwardRef in many common cases) 
  * use() API: Allows reading a Promise or resource directly inside render (instead of via side effects), with built-in support for Suspense, etc. 
               Simplifies async data fetching in some rendering scenarios.


* LAZY LOADING =================
      - Lazy loading is a frontend optimization where resources (like images, components, or routes) are loaded only when 
      they are needed, instead of all initially loading at once. This improves performance and reduces bandwidth usage.

      -     import React, { Suspense, lazy } from "react";

            const Profile = lazy(() => import("./Profile")); // Lazy load component
            
            function App() {
              return (
                <div>
                  <h1>Dashboard</h1>
                  <Suspense fallback={<p>Loading profile...</p>}>
                    <Profile />  {/* Loaded only when needed */}
                  </Suspense>
                </div>
              );
            }

      - Lazy loading does the Code splitting, which is a performance optimization technique where your applicationâ€™s JavaScript bundle is split
        into smaller chunks instead of one big file.


* React Virtualized============
       - React Virtualized is a popular library for efficiently rendering large lists, tables, and grids in React.
      
      ðŸ‘‰ Instead of rendering thousands of DOM nodes at once (which slows down the app), React Virtualized only renders the items that are visible
          in the viewport plus a small buffer.
      ðŸ‘‰ As you scroll, it reuses DOM nodes and renders new items dynamically.
      
      This technique is called windowing or virtualization.


* Ref ================
  - A ref is like a pointer for a value, or a DOM element.
  - It gives a way to directly access and interact with something React manages (like an <input> or a value that should persist across renders).
  - Unlike state, changing a ref does not trigger a re-render, and refs persist during re-renders. So refs can be used to store render counts.
  - const myRef = useRef(initialValue);   => useRef(initialValue) returns an object { current: initialValue } 
  - The ".current" property can be mutated freely.
  - Usage(to focus input) :
          const inputRef = useRef(null);  // Declaration

          <>
            <input ref={inputRef} type="text" />                  // now, this inputRef will contain the actual <input> DOM node.
            <button onClick={()=>inputRef.current.focus()}>Focus Input</button>   
          </>

 * React.StrictMode ===============
   - Itâ€™s a wrapper component that helps you find potential problems in your React code.
   - Think of it like a developer tool (it doesnâ€™t affect production).
   - Warns if you use outdated lifecycle methods
   - In React 18+, it intentionally runs certain functions twice (like useEffect cleanup/setup, component constructors, and render) 
     to help you spot side-effects that shouldnâ€™t exist.
   - Development-only tool for catching bugs early.

                                                        
