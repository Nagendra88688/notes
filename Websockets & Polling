======= Web sockets =========
* A WebSocket is a persistent, two-way connection between the browser and the server.
  Once connected, both client and server can send messages to each other at any timeâ€”no repeated requests needed.

* Example WebSocket in React:
    import { useEffect, useRef } from "react";
    
    const WebSocketComponent = () => {
      const socketRef = useRef(null);
    
      useEffect(() => {
        const socket = new WebSocket("wss://ws.postman-echo.com/raw");   // this url echoes back the same payload msg
        socketRef.current = socket;              // storing in ref to persist across re-renders
    
        socket.onopen = () => {
          console.log("Socket connected...");
        };
    
        socket.onmessage = (event) => {
          console.log(event?.data);        // this will log the same payload msg
        };
    
        return () => {
          socket.close();
        };
      }, []);
    
      const sendMessage = () => {
        socketRef.current?.send("Hello WebSocket! Nagi here");
      };
    
      return <button onClick={sendMessage}>Send</button>;
    };
    
    export default WebSocketComponent;


* Web socket is used for real-time updates, like chat apps, live dashboard, stock prices UI.



======== Polling ===============
* Polling is a technique where the client repeatedly requests the server at fixed intervals to check for updates, 
  commonly used for tracking long-running backend processes when real-time connections are not required.


* Simple polling example in React

          import { useEffect, useState } from "react";
          
          const PollingExample = () => {
            const [status, setStatus] = useState("pending");
          
            useEffect(() => {
              const intervalId = setInterval(async () => {
                const res = await fetch("/api/status");
                const data = await res.json();
          
                setStatus(data.status);
          
                if (data.status === "completed") {
                  clearInterval(intervalId);
                }
              }, 3000); // every 3 seconds
          
              return () => clearInterval(intervalId);
            }, []);
          
            return <div>Status: {status}</div>;
          };


* Problems with polling âŒ
  - Wastes network calls
  - Adds server load
  - Not real-time
  - Bad for high-frequency updates
  - Thatâ€™s why polling is not used for chat apps.


============== Server-Sent Events ===================
* Server-Sent Events provide a persistent HTTP connection where the server can push real-time updates to the client
  in a one-way stream, making them ideal for notifications and progress updates.

ðŸ”¹ Server pushes updates to the client
ðŸ”¹ Client cannot send messages back on the same connection


* Basic SSE server example:
    In Node.js file->
        app.get("/events", (req, res) => {
          res.setHeader("Content-Type", "text/event-stream");
          res.setHeader("Cache-Control", "no-cache");
          res.setHeader("Connection", "keep-alive");
        
          const interval = setInterval(() => {
            res.write(`data: ${JSON.stringify({ time: Date.now() })}\n\n`);
          }, 2000);
        
          req.on("close", () => {
            clearInterval(interval);
          });
        });

  Client in React->
        const SSEComponent = () => {
          useEffect(() => {
            const eventSource = new EventSource("/events");
        
            eventSource.onmessage = (event) => {
              console.log("Received:", event.data);
            };
      
            return () => {
              eventSource.close();
            };
          }, []);
        
          return <div>Listening to server events...</div>;
        };


* Used in video render progress, live notifications, where client don't need to request.

        

